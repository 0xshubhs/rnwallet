Implementation Plan: React Native Frontend & Node.js Backend for Ethereum Wallet Login
We build a React Native app that opens a WebView loading a hosted DApp page. The DApp page uses the injected window.ethereum provider (e.g. MetaMask mobile in-app browser) and ethers.js to connect the wallet, sign messages/transactions, and communicate results back to React Native via window.ReactNativeWebView.postMessage. The Node.js (TypeScript) backend provides endpoints for nonces, signature verification, and broadcasting transactions, using ethers.js utilities. No WalletConnect is used – instead we rely on in-app browser deep links or WebView injection.
Essential Libraries & Tools
	•	Backend (Node.js + TypeScript): ethers (for cryptographic utilities and transaction encoding), express (for HTTP API), body-parser/cors (request parsing), any random/crypto library (to generate nonces).
	•	Frontend (React Native): react-native-webview (to embed the DApp page), Linking (to open external wallets via deep links), and optionally expo-web-browser or similar for in-app browser.
	•	DApp Page (Web): plain HTML/JavaScript or React, using the ethers.js library (via CDN or bundler) to interact with window.ethereum.
For example, a project structure could be: 
project-root/ ├─ server/ │  ├─ src/ │  │  ├─ index.ts        # Express server setup │  │  ├─ routes/ │  │  │  ├─ auth.ts      # /nonce and /verify endpoints │  │  │  └─ tx.ts        # /createTx and /broadcast endpoints │  └─ package.json ├─ frontend/ │  ├─ App.js            # React Native entry point │  ├─ WalletWebView.js  # Component that manages the WebView │  └─ package.json └─ web/    ├─ index.html        # DApp page served by backend/static host    └─ dapp.js           # DApp page scripts (uses ethers.js)
Backend Implementation (Node.js + TypeScript)
	•	Initialize Express Server: Set up an Express app in server.ts (TypeScript), enabling JSON parsing and CORS. Install and import ethers.js. Use ethers.utils for cryptography. For example:
	•	import express from 'express'; import { ethers } from 'ethers'; const app = express(); app.use(express.json()); // ... setup CORS etc.
	•	Login Nonce Endpoint (/nonce): Provide a unique random nonce per session or login attempt. The frontend will fetch this and include it in the message to sign. For example, generate a UUID or random hex string:
	•	app.get('/api/nonce', (req, res) => {   const nonce = ethers.utils.hexlify(ethers.utils.randomBytes(16));   // store nonce server-side (e.g. in memory or DB) associated with the session/user   res.json({ nonce }); });
	•	Signature Verification Endpoint (/verify): Accept the signed message and address from the client. Use ethers.utils.verifyMessage(message, signature) to recover the address. Compare it with the claimed address. For example:
	•	app.post('/api/verify', (req, res) => {   const { address, signature, nonce } = req.body;   const message = `Login nonce: ${nonce}`;  // or format as used on client   try {     // Recover the address that signed the message     const signerAddr = ethers.utils.verifyMessage(message, signature);     if (signerAddr.toLowerCase() === address.toLowerCase()) {       // Signature is valid – authentication success       res.json({ success: true });     } else {       res.status(401).json({ error: 'Invalid signature' });     }   } catch (err) {     res.status(400).json({ error: 'Verification failed' });   } });
	•	This uses ethers.js to cryptographically verify the signature off-chain (no blockchain call needed)[1].
	•	Transaction Creation (optional): If the backend needs to prepare a transaction (e.g. fill in contract data), provide an endpoint like /createTx that takes parameters (to, value, data) and returns a JSON with the transaction object for signing. For example:
	•	app.post('/api/createTx', (req, res) => {   const { to, value, data } = req.body;   const tx = {     to,     value: ethers.BigNumber.from(value),     data: data || '0x',     // optionally set gasPrice or maxFee etc.   };   res.json({ tx }); });
	•	Broadcast Signed Transaction (/broadcast): After the client signs a transaction, it sends the raw signed transaction to this endpoint. Use an Ethereum provider (e.g. Infura or Alchemy) with ethers to broadcast. For example:
	•	app.post('/api/broadcast', async (req, res) => {   const { rawTx } = req.body;  // signed transaction hex   try {     const provider = new ethers.providers.JsonRpcProvider(YOUR_RPC_URL);     // Parse to inspect or get the sender (optional)     const parsed = ethers.utils.parseTransaction(rawTx);     console.log('Sender:', parsed.from);     // Broadcast     const txResponse = await provider.sendTransaction(rawTx);     res.json({ txHash: txResponse.hash });   } catch (err) {     res.status(400).json({ error: 'Broadcast failed' });   } });
	•	Ethers.js’s parseTransaction can decode fields (like from) from the signed raw tx[2]. The provider.sendTransaction() call will send the signed tx to the network[3].
Frontend Implementation (React Native + WebView)
	•	React Native Setup: In your RN app, install and import react-native-webview. Create a component (e.g. WalletWebView) that renders a <WebView> pointing to the DApp URL (hosted by your backend or static host). Example:
	•	import React from 'react'; import { WebView } from 'react-native-webview';  export default function WalletWebView({ onMessage }) {   return (     <WebView       source={{ uri: 'https://your-domain.com/dapp' }}       onMessage={onMessage}   // receives messages from DApp       javaScriptEnabled={true}       originWhitelist={['*']}     />   ); }
	•	In App.js, include a "Connect Wallet" button that either renders this WebView or uses Linking.openURL (see next point).
	•	Invoking the Wallet In-App Browser: To use MetaMask’s in-app browser, one can deep-link the user to the DApp URL. For example, when the user taps “Connect Wallet”, do:
	•	import { Linking } from 'react-native'; const dappUrl = 'https://your-domain.com/dapp'; const metaMaskDeepLink = `https://link.metamask.io/dapp/${dappUrl}`; Linking.openURL(metaMaskDeepLink);
	•	The MetaMask docs describe this deep link: https://link.metamask.io/dapp/{DAPP_URL} opens the URL in MetaMask’s mobile browser[4]. Other wallets have similar schemes (e.g. Trust Wallet or Rainbow). If the wallet app is installed, this opens it; otherwise the user is prompted to install. This approach bypasses WalletConnect entirely. Note that in this mode, communication back to RN must use a custom URI scheme or clipboard (beyond scope), so many apps simply embed a WebView as below.
	•	DApp Page (HTML/JS): On your DApp page (e.g. index.html at web/), include ethers.js (via CDN or bundler) and a script to handle Ethereum actions. For example:
	•	<!-- index.html --> <script src="https://cdn.jsdelivr.net/npm/ethers/dist/ethers.min.js"></script> <script>   async function connectAndLogin() {     if (!window.ethereum) {       alert('No Ethereum wallet found');       return;     }     // 1. Request account access     const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });     const address = accounts[0];     // 2. Get nonce from backend     const { nonce } = await fetch('/api/nonce').then(r => r.json());     // 3. Sign nonce     const provider = new ethers.providers.Web3Provider(window.ethereum);     const signer = provider.getSigner();     const signature = await signer.signMessage(`Login nonce: ${nonce}`);     // 4. Send signed message back to React Native     window.ReactNativeWebView.postMessage(JSON.stringify({       type: 'login',       address,       signature,       nonce     }));   }    // Expose the function (e.g. triggered by a button)   document.getElementById('connectButton').onclick = connectAndLogin; </script> <button id="connectButton">Connect Wallet</button>
	•	This DApp script requests eth_requestAccounts to prompt the wallet (MetaMask) to connect[5]. It then fetches a nonce, asks the wallet to sign it (using signer.signMessage, which under the hood sends personal_sign[6]), and posts the result to the React Native app via window.ReactNativeWebView.postMessage.
	•	React Native Message Handling: In your RN code, handle the messages from the WebView’s onMessage prop. For example:
	•	function handleWebViewMessage(event) {   const data = JSON.parse(event.nativeEvent.data);   if (data.type === 'login') {     // Data contains { address, signature, nonce }     fetch('https://your-api.com/api/verify', {       method: 'POST', headers: { 'Content-Type': 'application/json' },       body: JSON.stringify({          address: data.address,          signature: data.signature,          nonce: data.nonce        })     }).then(res => res.json())       .then(json => {         if (json.success) {           // Login succeeded         } else {           // Handle failure         }       });   }   // Similarly handle signed transactions if type === 'signedTx' }
	•	The RN code should parse the JSON and call the backend verify endpoint. A similar pattern applies if you implement transaction signing: have the DApp send type: 'signedTx', rawTx: ..., then RN posts to /broadcast.
	•	Signing Transactions in the DApp: For a generic transaction (e.g. to, value, data), the DApp can also initiate signing. If the RN app fetches a tx object from backend (via another API), it could inject it into the WebView (using WebView.postMessage and a message listener in the DApp) or simply navigate the WebView to a new URL with query parameters. For example, after obtaining a tx object {to, value, data}, the DApp script could do:
	•	async function signAndSendTx(tx) {   const provider = new ethers.providers.Web3Provider(window.ethereum);   const signer = provider.getSigner();   const signedTx = await signer.signTransaction(tx);   window.ReactNativeWebView.postMessage(JSON.stringify({     type: 'signedTx',     rawTx: signedTx   })); }
	•	(Note: signTransaction returns a raw signed tx hex). The RN side would catch this and POST it to the /broadcast endpoint. Ethers docs note the signer.signTransaction utility[3] and the raw tx can then be sent via eth_sendRawTransaction on the backend.
	•	Deep Linking vs. In-App WebView: If you use the MetaMask deep link (link.metamask.io), the DApp runs inside the MetaMask app, so window.ethereum is automatically available. In that case, you cannot directly use window.ReactNativeWebView.postMessage (since the page isn’t in your RN WebView). One workaround is to use a custom URI scheme to return data to your app, but that is complex. An alternative is to embed a standard WebView in your app (as above) and rely on injection or Wallet API (e.g. MetaMask Mobile SDK). For simplicity, many developers keep the WebView in-app and instruct users to trust the app. Always clarify to users that no private keys ever leave their wallet – the backend only verifies signatures or broadcasts signed data (never stores keys).
Step-by-Step Flow Summary
	•	User taps “Connect Wallet” in the React Native app.
	•	Open WebView (or MetaMask in-app browser) to load your DApp page.
	•	DApp page calls window.ethereum.request({method: 'eth_requestAccounts'}) to connect wallet[5]. The wallet prompts the user to approve.
	•	Backend creates a login nonce and returns it via /api/nonce.
	•	DApp page calls signer.signMessage(nonce) (i.e. personal_sign)[6] to have the wallet sign the nonce.
	•	DApp page sends the signed message and address back to React Native via window.ReactNativeWebView.postMessage.
	•	React Native app receives the message, posts it to /api/verify. The backend uses ethers.utils.verifyMessage to check the signature and match the address (as per[1]).
	•	(After login) When the user initiates a transaction, the RN app fetches transaction details or parameters from the backend (/api/createTx) or defines them itself.
	•	DApp page receives the transaction data (could be via page parameters or window.postMessage), and calls signer.signTransaction(tx) or directly signer.sendTransaction(tx) to prompt the wallet UI.
	•	The signed raw transaction is passed back to RN (postMessage) and RN calls /api/broadcast.
	•	Backend broadcasts the raw transaction via provider.sendTransaction(rawTx)[3]. Ethers’s parseTransaction was used to inspect fields if needed[2].
Key Points and Libraries
	•	No WalletConnect: We rely on the wallet’s built-in browser or injected window.ethereum. MetaMask’s official deep link is documented as https://link.metamask.io/dapp/{dappUrl}[4]. WalletConnect is explicitly not used here, so the flow stays within the app/WebView.
	•	ethers.js: Both frontend (DApp) and backend use ethers.js for convenience. On the frontend, ethers.providers.Web3Provider(window.ethereum) and signer.signMessage or sendTransaction interact with MetaMask. On the backend, ethers.utils.verifyMessage and parseTransaction help process data[1][2].
	•	React Native WebView Messaging: Use window.ReactNativeWebView.postMessage(JSON.stringify(data)) in the DApp, and the RN WebView’s onMessage prop to receive it. (Ensure the message is a string.)
	•	MetaMask & Other Wallets: For MetaMask mobile, use the above deep link. Other wallets may support similar in-app browser URLs or custom URI schemes (e.g. trust://, cobo://, etc.), which you can explore individually.
	•	Security: The backend never holds private keys. All signing is done client-side by the user’s wallet. The backend merely verifies signatures or broadcasts signed data. The login nonce prevents replay attacks (each signature is unique to that session).
By following this plan—with backend endpoints for nonces, signature verification and transaction forwarding, and a React Native front end that loads a WebView DApp for wallet interaction—you can achieve secure Ethereum wallet login and transaction signing without WalletConnect, using ethers.js throughout[5][3].
Sources: MetaMask dev docs (on deep links[4], accounts and signing[5][6]) and ethers.js guides (on message verification[1] and transactions[2][3]). These informed the code examples and method choices above.

[1] [3] How to Verify Message Signatures on Ethereum | Quicknode Guides
https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum
[2] Transactions
https://docs.ethers.org/v5/api/utils/transactions/
[4] Use deeplinks | MetaMask developer documentation
https://docs.metamask.io/sdk/guides/use-deeplinks/
[5] Access a user's accounts | MetaMask developer documentation
https://docs.metamask.io/wallet/how-to/access-accounts/
[6] Sign data | MetaMask developer documentation
https://docs.metamask.io/wallet/how-to/sign-data/
